// Copyright 2019-2023 ChainSafe Systems
// SPDX-License-Identifier: Apache-2.0, MIT

use std::sync::Arc;

use crate::blocks::Tipset;
use crate::chain::block_messages;
use crate::chain::index::ChainIndex;
use crate::chain::store::Error;
use crate::interpreter::{fvm2::ForestExternsV2, fvm3::ForestExterns as ForestExternsV3};
use crate::message::ChainMessage;
use crate::message::Message as MessageTrait;
use crate::networks::{ChainConfig, NetworkChain};
use crate::shim::{
    address::Address,
    econ::TokenAmount,
    executor::{ApplyRet, Receipt},
    externs::{Rand, RandWrapper},
    machine::MultiEngine,
    message::{Message, Message_v3},
    state_tree::ActorState,
    version::NetworkVersion,
};
use ahash::{HashMap, HashMapExt, HashSet};
use anyhow::bail;
use cid::Cid;
use fil_actor_interface::{cron, reward, AwardBlockRewardParams};
use fvm2::{
    executor::{DefaultExecutor as DefaultExecutor_v2, Executor as Executor_v2},
    machine::{
        DefaultMachine as DefaultMachine_v2, Machine as Machine_v2,
        NetworkConfig as NetworkConfig_v2,
    },
};
use fvm3::{
    executor::{DefaultExecutor as DefaultExecutor_v3, Executor as Executor_v3},
    machine::{
        DefaultMachine as DefaultMachine_v3, Machine as Machine_v3,
        NetworkConfig as NetworkConfig_v3,
    },
};
use fvm_ipld_blockstore::Blockstore;
use fvm_ipld_encoding::{to_vec, RawBytes};
use fvm_shared2::clock::ChainEpoch;
use num::Zero;

pub(in crate::interpreter) type ForestMachineV2<DB> =
    DefaultMachine_v2<Arc<DB>, ForestExternsV2<DB>>;
pub(in crate::interpreter) type ForestMachineV3<DB> =
    DefaultMachine_v3<Arc<DB>, ForestExternsV3<DB>>;

type ForestKernelV2<DB> =
    fvm2::DefaultKernel<fvm2::call_manager::DefaultCallManager<ForestMachineV2<DB>>>;
type ForestKernelV3<DB> =
    fvm3::DefaultKernel<fvm3::call_manager::DefaultCallManager<ForestMachineV3<DB>>>;
type ForestExecutorV2<DB> = DefaultExecutor_v2<ForestKernelV2<DB>>;
type ForestExecutorV3<DB> = DefaultExecutor_v3<ForestKernelV3<DB>>;

/// Comes from <https://github.com/filecoin-project/lotus/blob/v1.23.2/chain/vm/fvm.go#L473>
const IMPLICIT_MESSAGE_GAS_LIMIT: i64 = i64::MAX / 2;

/// Contains all messages to process through the VM as well as miner information
/// for block rewards.
#[derive(Debug)]
pub struct BlockMessages {
    pub miner: Address,
    pub messages: Vec<ChainMessage>,
    pub win_count: i64,
}

impl BlockMessages {
    /// Retrieves block messages to be passed through the VM and removes duplicate messages which appear in multiple blocks.
    pub fn for_tipset(db: impl Blockstore, ts: &Tipset) -> Result<Vec<BlockMessages>, Error> {
        let mut applied = HashMap::new();
        let mut select_msg = |m: ChainMessage| -> Option<ChainMessage> {
            // The first match for a sender is guaranteed to have correct nonce
            // the block isn't valid otherwise.
            let entry = applied.entry(m.from()).or_insert_with(|| m.sequence());

            if *entry != m.sequence() {
                return None;
            }

            *entry += 1;
            Some(m)
        };

        ts.blocks()
            .iter()
            .map(|b| {
                let (usm, sm) = block_messages(&db, b)?;

                let mut messages = Vec::with_capacity(usm.len() + sm.len());
                messages.extend(
                    usm.into_iter()
                        .filter_map(|m| select_msg(ChainMessage::Unsigned(m))),
                );
                messages.extend(
                    sm.into_iter()
                        .filter_map(|m| select_msg(ChainMessage::Signed(m))),
                );

                Ok(BlockMessages {
                    miner: *b.miner_address(),
                    messages,
                    win_count: b
                        .election_proof()
                        .as_ref()
                        .map(|e| e.win_count)
                        .unwrap_or_default(),
                })
            })
            .collect()
    }
}

/// Interpreter which handles execution of state transitioning messages and
/// returns receipts from the VM execution.
pub enum VM<DB: Blockstore + Send + Sync + 'static> {
    VM2(ForestExecutorV2<DB>),
    VM3(ForestExecutorV3<DB>),
}

pub struct ExecutionContext<DB> {
    // This tipset identifies of the blockchain. It functions as a starting
    // point when searching for ancestors. It may be any tipset as long as its
    // epoch is at or higher than the epoch in `epoch`.
    pub heaviest_tipset: Arc<Tipset>,
    // State-tree generated by the parent tipset.
    pub state_tree_root: Cid,
    // Epoch of the messages to be executed.
    pub epoch: ChainEpoch,
    // Source of deterministic randomness
    pub rand: Box<dyn Rand>,
    // https://spec.filecoin.io/systems/filecoin_vm/gas_fee/
    pub base_fee: TokenAmount,
    // https://filecoin.io/blog/filecoin-circulating-supply/
    pub circ_supply: TokenAmount,
    // The chain config is used to determine which consensus rules to use.
    pub chain_config: Arc<ChainConfig>,
    // Caching interface to the DB
    pub chain_index: Arc<ChainIndex<Arc<DB>>>,
    // UNIX timestamp for epoch
    pub timestamp: u64,
}

impl<DB> VM<DB>
where
    DB: Blockstore + Send + Sync,
{
    pub fn new(
        ExecutionContext {
            heaviest_tipset,
            state_tree_root,
            epoch,
            rand,
            base_fee,
            circ_supply,
            chain_config,
            chain_index,
            timestamp,
        }: ExecutionContext<DB>,
        multi_engine: &MultiEngine,
        enable_tracing: VMTrace,
    ) -> Result<Self, anyhow::Error> {
        let network_version = chain_config.network_version(epoch);
        if network_version >= NetworkVersion::V18 {
            let mut config = NetworkConfig_v3::new(network_version.into());
            // ChainId defines the chain ID used in the Ethereum JSON-RPC endpoint.
            config.chain_id(chain_config.eth_chain_id.into());
            if let NetworkChain::Devnet(_) = chain_config.network {
                config.enable_actor_debugging();
            }

            let engine = multi_engine.v3.get(&config)?;
            let mut context = config.for_epoch(epoch, timestamp, state_tree_root);
            context.set_base_fee(base_fee.into());
            context.set_circulating_supply(circ_supply.into());
            context.tracing = enable_tracing.is_traced();

            let fvm: ForestMachineV3<DB> = ForestMachineV3::new(
                &context,
                Arc::clone(&chain_index.db),
                ForestExternsV3::new(
                    RandWrapper::from(rand),
                    heaviest_tipset,
                    epoch,
                    state_tree_root,
                    chain_index,
                    chain_config,
                ),
            )?;
            let exec: ForestExecutorV3<DB> = DefaultExecutor_v3::new(engine, fvm)?;
            Ok(VM::VM3(exec))
        } else {
            let config = NetworkConfig_v2::new(network_version.into());
            let engine = multi_engine.v2.get(&config)?;
            let mut context = config.for_epoch(epoch, state_tree_root);
            context.set_base_fee(base_fee.into());
            context.set_circulating_supply(circ_supply.into());
            context.tracing = enable_tracing.is_traced();

            let fvm: ForestMachineV2<DB> = ForestMachineV2::new(
                &engine,
                &context,
                Arc::clone(&chain_index.db),
                ForestExternsV2::new(
                    RandWrapper::from(rand),
                    heaviest_tipset,
                    epoch,
                    state_tree_root,
                    chain_index,
                    chain_config,
                ),
            )?;
            let exec: ForestExecutorV2<DB> = DefaultExecutor_v2::new(fvm);
            Ok(VM::VM2(exec))
        }
    }

    /// Flush stores in VM and return state root.
    pub fn flush(&mut self) -> anyhow::Result<Cid> {
        match self {
            VM::VM2(fvm_executor) => Ok(fvm_executor.flush()?),
            VM::VM3(fvm_executor) => Ok(fvm_executor.flush()?),
        }
    }

    /// Get actor state from an address. Will be resolved to ID address.
    pub fn get_actor(&self, addr: &Address) -> Result<Option<ActorState>, anyhow::Error> {
        match self {
            VM::VM2(fvm_executor) => Ok(fvm_executor
                .state_tree()
                .get_actor(&addr.into())?
                .map(ActorState::from)),
            VM::VM3(fvm_executor) => {
                if let Some(id) = fvm_executor.state_tree().lookup_id(&addr.into())? {
                    Ok(fvm_executor
                        .state_tree()
                        .get_actor(id)?
                        .map(ActorState::from))
                } else {
                    Ok(None)
                }
            }
        }
    }

    pub fn run_cron(
        &mut self,
        epoch: ChainEpoch,
        callback: Option<
            &mut impl FnMut(&Cid, &ChainMessage, &ApplyRet, CalledAt) -> Result<(), anyhow::Error>,
        >,
    ) -> Result<(Message, ApplyRet), anyhow::Error> {
        let cron_msg: Message = Message_v3 {
            from: Address::SYSTEM_ACTOR.into(),
            to: Address::CRON_ACTOR.into(),
            // Epoch as sequence is intentional
            sequence: epoch as u64,
            // Arbitrarily large gas limit for cron (matching Lotus value)
            gas_limit: IMPLICIT_MESSAGE_GAS_LIMIT as u64,
            method_num: cron::Method::EpochTick as u64,
            params: Default::default(),
            value: Default::default(),
            version: Default::default(),
            gas_fee_cap: Default::default(),
            gas_premium: Default::default(),
        }
        .into();

        let ret = self.apply_implicit_message(&cron_msg)?;
        if let Some(err) = ret.failure_info() {
            anyhow::bail!("failed to apply block cron message: {}", err);
        }

        if let Some(callback) = callback {
            callback(
                &(cron_msg.cid()?),
                &ChainMessage::Unsigned(cron_msg.clone()),
                &ret,
                CalledAt::Cron,
            )?;
        }
        Ok((cron_msg, ret))
    }

    /// Apply block messages from a Tipset.
    /// Returns the receipts from the transactions.
    pub fn apply_block_messages(
        &mut self,
        messages: &[BlockMessages],
        epoch: ChainEpoch,
        // JANK(aatifsyed):
        // - why is this optional?
        // - why does it allow breaking out of this function?
        //   is it an observer or pluggable logic?
        mut callback: Option<
            impl FnMut(&Cid, &ChainMessage, &ApplyRet, CalledAt) -> Result<(), anyhow::Error>,
        >,
    ) -> Result<Vec<Receipt>, anyhow::Error> {
        let mut receipts = Vec::new();
        let mut processed = HashSet::<Cid>::default();

        for block in messages.iter() {
            let mut penalty = TokenAmount::zero();
            let mut gas_reward = TokenAmount::zero();

            let mut process_msg = |msg: &ChainMessage| -> Result<(), anyhow::Error> {
                let cid = msg.cid()?;
                // Ensure no duplicate processing of a message
                if processed.contains(&cid) {
                    return Ok(());
                }
                let ret = self.apply_message(msg)?;

                if let Some(cb) = &mut callback {
                    cb(&cid, msg, &ret, CalledAt::Applied)?;
                }

                // Update totals
                gas_reward += ret.miner_tip();
                penalty += ret.penalty();
                let msg_receipt = ret.msg_receipt();
                receipts.push(msg_receipt.clone());

                // Add processed Cid to set of processed messages
                processed.insert(cid);
                Ok(())
            };

            for msg in block.messages.iter() {
                // JANK(aatifsyed): why not inline the callback?
                process_msg(msg)?;
            }

            // Generate reward transaction for the miner of the block
            if let Some(rew_msg) =
                self.reward_message(epoch, block.miner, block.win_count, penalty, gas_reward)?
            {
                let ret = self.apply_implicit_message(&rew_msg)?;
                if let Some(err) = ret.failure_info() {
                    anyhow::bail!(
                        "failed to apply reward message for miner {}: {}",
                        block.miner,
                        err
                    );
                }
                // This is more of a sanity check, this should not be able to be hit.
                if !ret.msg_receipt().exit_code().is_success() {
                    anyhow::bail!(
                        "reward application message failed (exit: {:?})",
                        ret.msg_receipt().exit_code()
                    );
                }

                if let Some(callback) = &mut callback {
                    callback(
                        &(rew_msg.cid()?),
                        &ChainMessage::Unsigned(rew_msg),
                        &ret,
                        CalledAt::Reward,
                    )?;
                }
            }
        }

        if let Err(e) = self.run_cron(epoch, callback.as_mut()) {
            // BUG(aatifsyed): why are we ignoring this error?
            tracing::error!("End of epoch cron failed to run: {}", e);
        }

        Ok(receipts)
    }

    /// Applies single message through VM and returns result from execution.
    pub fn apply_implicit_message(&mut self, msg: &Message) -> Result<ApplyRet, anyhow::Error> {
        // raw_length is not used for Implicit messages.
        let raw_length = to_vec(msg).expect("encoding error").len();

        match self {
            VM::VM2(fvm_executor) => {
                let ret = fvm_executor.execute_message(
                    msg.into(),
                    fvm2::executor::ApplyKind::Implicit,
                    raw_length,
                )?;
                Ok(ret.into())
            }
            VM::VM3(fvm_executor) => {
                let ret = fvm_executor.execute_message(
                    msg.into(),
                    fvm3::executor::ApplyKind::Implicit,
                    raw_length,
                )?;
                Ok(ret.into())
            }
        }
    }

    /// Applies the state transition for a single message.
    /// Returns `ApplyRet` structure which contains the message receipt and some
    /// meta data.
    pub fn apply_message(&mut self, msg: &ChainMessage) -> Result<ApplyRet, anyhow::Error> {
        // Basic validity check
        msg.message().check()?;

        let unsigned = msg.message().clone();
        let raw_length = to_vec(msg).expect("encoding error").len();
        let ret: ApplyRet = match self {
            VM::VM2(fvm_executor) => {
                let ret = fvm_executor.execute_message(
                    unsigned.into(),
                    fvm2::executor::ApplyKind::Explicit,
                    raw_length,
                )?;

                if fvm_executor.externs().bail() {
                    bail!("encountered a database lookup error");
                }

                ret.into()
            }
            VM::VM3(fvm_executor) => {
                let ret = fvm_executor.execute_message(
                    unsigned.into(),
                    fvm3::executor::ApplyKind::Explicit,
                    raw_length,
                )?;

                if fvm_executor.externs().bail() {
                    bail!("encountered a database lookup error");
                }

                ret.into()
            }
        };

        let exit_code = ret.msg_receipt().exit_code();

        if !exit_code.is_success() {
            tracing::debug!(?exit_code, "VM message execution failure.")
        }

        Ok(ret)
    }

    fn reward_message(
        &self,
        epoch: ChainEpoch,
        miner: Address,
        win_count: i64,
        penalty: TokenAmount,
        gas_reward: TokenAmount,
    ) -> Result<Option<Message>, anyhow::Error> {
        let params = RawBytes::serialize(AwardBlockRewardParams {
            miner: miner.into(),
            penalty: penalty.into(),
            gas_reward: gas_reward.into(),
            win_count,
        })?;
        let rew_msg = Message_v3 {
            from: Address::SYSTEM_ACTOR.into(),
            to: Address::REWARD_ACTOR.into(),
            method_num: reward::Method::AwardBlockReward as u64,
            params,
            // Epoch as sequence is intentional
            sequence: epoch as u64,
            gas_limit: IMPLICIT_MESSAGE_GAS_LIMIT as u64,
            value: Default::default(),
            version: Default::default(),
            gas_fee_cap: Default::default(),
            gas_premium: Default::default(),
        };
        Ok(Some(rew_msg.into()))
    }
}

// TODO(aatifsyed): struct CallbackCtx<'a> { cid: &'a Cid, at: CalledAt, .. }
pub enum CalledAt {
    Applied,
    Reward,
    Cron,
}

/// Tracing a Filecoin VM has a performance penalty.
/// This enum controls whether a VM should be traced or not
#[derive(Default, Clone, Copy)]
pub enum VMTrace {
    /// Collect trace for the given operation
    Traced,
    /// Do not collect trace
    #[default]
    NotTraced,
}

impl VMTrace {
    /// Should tracing be collected?
    pub fn is_traced(&self) -> bool {
        matches!(self, VMTrace::Traced)
    }
}

/// Several operations in the FVM can be "traced", e.g
/// - [`crate::interpreter::VM::apply_block_messages`]
///
/// (See the appropriate fields on [`ApplyRet`](https://docs.rs/fvm/2.2.0/fvm/executor/struct.ApplyRet.html#structfield.exec_trace) for more context.)
///
/// This involves _logical tracing_, where e.g message executions are accumulated
/// in-code, for displaying to the user e.g [`crate::cli::subcommands::snapshot_cmd::SnapshotCommands::ComputeState`].
///
/// # API Hazard
/// This needs careful redesign: <https://github.com/ChainSafe/forest/issues/3405>
mod trace {
    use crate::message::Message as _;
    use crate::shim::address::Address;
    use crate::shim::econ::TokenAmount;
    use crate::shim::message::MethodNum;
    use crate::shim::{
        executor::{ApplyRet, ExecutionEvent_v3, Receipt},
        message::Message,
    };
    use cid::Cid;
    use fvm3::gas::GasCharge as GasChargeV3;
    use fvm_ipld_encoding::ipld_block::IpldBlock;
    use fvm_shared3::error::ErrorNumber;
    use fvm_shared3::error::ExitCode;
    use num_bigint::BigInt;
    use serde::{Deserialize, Serialize};
    use std::borrow::Cow;

    /// Ported from <https://github.com/filecoin-project/filecoin-ffi/blob/v1.23.0/rust/src/fvm/machine.rs#L207>
    fn build_exec_trace(exec_trace: Vec<ExecutionEvent_v3>) -> Option<Trace> {
        let mut trace_iter = exec_trace.into_iter();
        let mut initial_gas_charges = Vec::new();
        loop {
            match trace_iter.next() {
                Some(gc @ ExecutionEvent_v3::GasCharge(_)) => initial_gas_charges.push(gc),
                Some(ExecutionEvent_v3::Call {
                    from,
                    to,
                    method,
                    params,
                    value,
                }) => {
                    break build_lotus_trace(
                        from,
                        to.into(),
                        method,
                        params.clone(),
                        value.into(),
                        &mut initial_gas_charges.into_iter().chain(&mut trace_iter),
                    )
                    .ok()
                }
                // Skip anything unexpected.
                Some(_) => {}
                // Return none if we don't even have a call.
                None => break None,
            }
        }
    }

    #[derive(Default, Serialize, Deserialize)]
    #[serde(rename_all = "PascalCase")]
    pub struct TraceComputeState {
        #[serde(with = "crate::lotus_json")]
        root: Cid,
        trace: Vec<TraceMessageInvocation>,
    }

    impl TraceComputeState {
        pub fn new(root: Cid, trace: Vec<TraceMessageInvocation>) -> Self {
            Self { root, trace }
        }
    }

    #[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]
    #[cfg_attr(test, derive(derive_quickcheck_arbitrary::Arbitrary))]
    struct TraceMessageGasCost {
        #[serde(with = "crate::lotus_json")]
        message: Option<Cid>,
        #[serde(with = "crate::lotus_json")]
        gas_used: BigInt,
        #[serde(with = "crate::lotus_json")]
        base_fee_burn: TokenAmount,
        #[serde(with = "crate::lotus_json")]
        over_estimation_burn: TokenAmount,
        #[serde(with = "crate::lotus_json")]
        miner_penalty: TokenAmount,
        #[serde(with = "crate::lotus_json")]
        miner_tip: TokenAmount,
        #[serde(with = "crate::lotus_json")]
        refund: TokenAmount,
        #[serde(with = "crate::lotus_json")]
        total_cost: TokenAmount,
    }

    impl TraceMessageGasCost {
        fn new(msg: &Message, ret: &ApplyRet) -> Self {
            Self {
                message: Some(msg.cid().unwrap()),
                gas_used: BigInt::from(ret.msg_receipt().gas_used()),
                base_fee_burn: ret.base_fee_burn(),
                over_estimation_burn: ret.over_estimation_burn(),
                miner_penalty: ret.penalty(),
                miner_tip: ret.miner_tip(),
                refund: ret.refund(),
                total_cost: msg.required_funds() - &ret.refund(),
            }
        }

        fn from_implicit(msg: &Message, ret: &ApplyRet) -> Self {
            Self {
                message: None,
                gas_used: BigInt::default(),
                ..Self::new(msg, ret)
            }
        }
    }

    #[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]
    #[serde(rename_all = "PascalCase")]
    pub struct TraceMessageInvocation {
        #[serde(with = "crate::lotus_json")]
        msg_cid: Cid,
        #[serde(with = "crate::lotus_json")]
        msg: Message,
        #[serde(with = "crate::lotus_json")]
        #[serde(rename = "MsgRct")]
        msg_receipt: Receipt,
        gas_cost: TraceMessageGasCost,
        execution_trace: Option<Trace>,
        error: String,
        duration: u64,
    }

    impl TraceMessageInvocation {
        pub(super) fn new(msg_cid: Cid, msg: &Message, ret: &ApplyRet) -> Self {
            let trace = build_exec_trace(ret.exec_trace());
            Self {
                msg_cid,
                msg: msg.clone(),
                msg_receipt: ret.msg_receipt(),
                gas_cost: TraceMessageGasCost::new(msg, ret),
                execution_trace: trace,
                error: ret.failure_info().unwrap_or_default(),
                duration: 0,
            }
        }

        pub(super) fn from_implicit(msg_cid: Cid, msg: &Message, ret: &ApplyRet) -> Self {
            Self {
                gas_cost: TraceMessageGasCost::from_implicit(msg, ret),
                ..Self::new(msg_cid, msg, ret)
            }
        }
    }

    // We match Lotus structures and code to have similar json trace and an easier diff:
    // https://github.com/filecoin-project/filecoin-ffi/blob/v1.23.0/rust/src/fvm/machine.rs#L391
    #[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]
    #[serde(rename_all = "PascalCase")]
    struct TraceGasCharge {
        name: Cow<'static, str>,
        #[serde(rename = "tg")]
        total_gas: u64,
        #[serde(rename = "cg")]
        compute_gas: u64,
        #[serde(rename = "sg")]
        other_gas: u64,
        #[serde(rename = "tt")]
        duration_nanos: u64,
    }

    #[derive(Default, PartialEq, Clone, Debug, Serialize, Deserialize)]
    #[serde(rename_all = "PascalCase")]
    struct Trace {
        msg: TraceMessage,
        #[serde(rename = "MsgRct")]
        msg_ret: TraceReturn,
        gas_charges: Vec<TraceGasCharge>,
        subcalls: Vec<Trace>,
    }

    #[derive(Default, PartialEq, Clone, Debug, Serialize, Deserialize)]
    #[serde(rename_all = "PascalCase")]
    struct TraceMessage {
        #[serde(with = "crate::lotus_json")]
        from: Address,
        #[serde(with = "crate::lotus_json")]
        to: Address,
        #[serde(with = "crate::lotus_json")]
        value: TokenAmount,
        #[serde(rename = "Method")]
        method_num: MethodNum,
        #[serde(with = "crate::lotus_json")]
        params: Vec<u8>,
        params_codec: u64,
    }

    #[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]
    #[serde(rename_all = "PascalCase")]
    struct TraceReturn {
        exit_code: ExitCode,
        #[serde(rename = "Return", with = "crate::lotus_json")]
        return_data: Vec<u8>,
        return_codec: u64,
    }

    impl Default for TraceReturn {
        fn default() -> Self {
            Self {
                exit_code: ExitCode::OK,
                return_data: vec![],
                return_codec: 0,
            }
        }
    }

    fn build_lotus_trace(
        from: u64,
        to: Address,
        method: u64,
        params: Option<IpldBlock>,
        value: TokenAmount,
        trace_iter: &mut impl Iterator<Item = ExecutionEvent_v3>,
    ) -> anyhow::Result<Trace> {
        let params = params.unwrap_or_default();
        let mut new_trace = Trace {
            msg: TraceMessage {
                from: Address::new_id(from),
                to,
                value,
                method_num: method,
                params: params.data,
                params_codec: params.codec,
            },
            msg_ret: TraceReturn {
                exit_code: ExitCode::OK,
                return_data: Vec::new(),
                return_codec: 0,
            },
            gas_charges: vec![],
            subcalls: vec![],
        };

        while let Some(trace) = trace_iter.next() {
            match trace {
                ExecutionEvent_v3::Call {
                    from,
                    to,
                    method,
                    params,
                    value,
                } => {
                    new_trace.subcalls.push(build_lotus_trace(
                        from,
                        to.into(),
                        method,
                        params,
                        value.into(),
                        trace_iter,
                    )?);
                }
                ExecutionEvent_v3::CallReturn(exit_code, return_data) => {
                    let return_data = return_data.unwrap_or_default();
                    new_trace.msg_ret = TraceReturn {
                        exit_code,
                        return_data: return_data.data,
                        return_codec: return_data.codec,
                    };
                    return Ok(new_trace);
                }
                ExecutionEvent_v3::CallError(syscall_err) => {
                    // Errors indicate the message couldn't be dispatched at all
                    // (as opposed to failing during execution of the receiving actor).
                    // These errors are mapped to exit codes that persist on chain.
                    let exit_code = match syscall_err.1 {
                        ErrorNumber::InsufficientFunds => ExitCode::SYS_INSUFFICIENT_FUNDS,
                        ErrorNumber::NotFound => ExitCode::SYS_INVALID_RECEIVER,
                        _ => ExitCode::SYS_ASSERTION_FAILED,
                    };

                    new_trace.msg_ret = TraceReturn {
                        exit_code,
                        return_data: Default::default(),
                        return_codec: 0,
                    };
                    return Ok(new_trace);
                }
                ExecutionEvent_v3::GasCharge(GasChargeV3 {
                    name,
                    compute_gas,
                    other_gas,
                    elapsed,
                }) => {
                    new_trace.gas_charges.push(TraceGasCharge {
                        name,
                        total_gas: (compute_gas + other_gas).round_up(),
                        compute_gas: compute_gas.round_up(),
                        other_gas: other_gas.round_up(),
                        duration_nanos: elapsed
                            .get()
                            .copied()
                            .unwrap_or_default()
                            .as_nanos()
                            .try_into()
                            .unwrap_or(u64::MAX),
                    });
                }
                _ => (), // ignore unknown events.
            };
        }

        panic!("should have returned on an ExecutionEvent:Return")
    }
}

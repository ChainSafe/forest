pub static TIPSET_PROCESSING_TIME: Lazy<Box<Histogram>> = Lazy::new(|| {
    let tipset_processing_time = Box::new(
        Histogram::with_opts(HistogramOpts {
                common_opts: Opts::new(
                    "tipset_processing_time",
                    "Duration of routine which processes Tipsets to include them in the store",
                ),
                buckets: vec![],
            })
            .expect("Defining the tipset_processing_time metric must succeed"),
    );
    prometheus::default_registry()
        .register(tipset_processing_time.clone())
        .expect(
            "Registering the tipset_processing_time metric with the metrics registry must succeed",
        );
    tipset_processing_time
});
pub static BLOCK_VALIDATION_TIME: Lazy<Box<Histogram>> = Lazy::new(|| {
    let block_validation_time = Box::new(
        Histogram::with_opts(HistogramOpts {
                common_opts: Opts::new(
                    "block_validation_time",
                    "Duration of routine which validate blocks with no cache hit",
                ),
                buckets: vec![],
            })
            .expect("Defining the block_validation_time metric must succeed"),
    );
    prometheus::default_registry()
        .register(block_validation_time.clone())
        .expect(
            "Registering the block_validation_time metric with the metrics registry must succeed",
        );
    block_validation_time
});
pub static BLOCK_VALIDATION_TASKS_TIME: Lazy<Box<HistogramVec>> = Lazy::new(|| {
    let block_validation_tasks_time = Box::new(
        HistogramVec::new(
                HistogramOpts {
                    common_opts: Opts::new(
                        "block_validation_tasks_time",
                        "Duration of subroutines inside block validation",
                    ),
                    buckets: vec![],
                },
                &["type"],
            )
            .expect("Defining the block_validation_time metric must succeed"),
    );
    prometheus::default_registry()
        .register(block_validation_tasks_time.clone())
        .expect(
            "Registering the block_validation_time metric with the metrics registry must succeed",
        );
    block_validation_tasks_time
});
pub static LIBP2P_MESSAGE_TOTAL: Lazy<Box<GenericCounterVec<AtomicU64>>> = Lazy::new(|| {
    let libp2p_message_total = Box::new(
        GenericCounterVec::<
            AtomicU64,
        >::new(
                Opts::new(
                    "libp2p_messsage_total",
                    "Total number of libp2p messages by type",
                ),
                &[labels::GOSSIPSUB_MESSAGE_KIND],
            )
            .expect("Defining the libp2p_message_total metric must succeed"),
    );
    prometheus::default_registry()
        .register(libp2p_message_total.clone())
        .expect(
            "Registering the libp2p_message_total metric with the metrics registry must succeed",
        );
    libp2p_message_total
});
pub static INVALID_TIPSET_TOTAL: Lazy<Box<GenericCounter<AtomicU64>>> = Lazy::new(|| {
    let invalid_tipset_total = Box::new(
        GenericCounter::<
            AtomicU64,
        >::new(
                "invalid_tipset_total",
                "Total number of invalid tipsets received over gossipsub",
            )
            .expect("Defining the invalid_tipset_total metric must succeed"),
    );
    prometheus::default_registry()
        .register(invalid_tipset_total.clone())
        .expect(
            "Registering the invalid_tipset_total metric with the metrics registry must succeed",
        );
    invalid_tipset_total
});
pub static TIPSET_RANGE_SYNC_FAILURE_TOTAL: Lazy<Box<GenericCounter<AtomicU64>>> = Lazy::new(||
{
    let tipset_range_sync_failure_total = Box::new(
        GenericCounter::<
            AtomicU64,
        >::new(
                "tipset_range_sync_failure_total",
                "Total number of errors produced by TipsetRangeSyncers",
            )
            .expect("Defining the tipset_range_sync_failure_total metrics must succeed"),
    );
    prometheus::default_registry()
        .register(tipset_range_sync_failure_total.clone())
        .expect(
            "Registering the tipset_range_sync_failure_total metric with the metrics registry must succeed",
        );
    tipset_range_sync_failure_total
});
pub static HEAD_EPOCH: Lazy<Box<GenericGauge<AtomicU64>>> = Lazy::new(|| {
    let head_epoch = Box::new(
        GenericGauge::<
            AtomicU64,
        >::new("head_epoch", "Latest epoch synchronized to the node")
            .expect("Defining the head_epoch metric must succeed"),
    );
    prometheus::default_registry()
        .register(head_epoch.clone())
        .expect(
            "Registering the head_epoch metric with the metrics registry must succeed",
        );
    head_epoch
});
pub static LAST_VALIDATED_TIPSET_EPOCH: Lazy<Box<GenericGauge<AtomicU64>>> = Lazy::new(||
{
    let last_validated_tipset_epoch = Box::new(
        GenericGauge::new("last_validated_tipset_epoch", "Last validated tipset epoch")
            .expect("Defining the last_validated_tipset_epoch metric must succeed"),
    );
    prometheus::default_registry()
        .register(last_validated_tipset_epoch.clone())
        .expect(
            "Registering the last_validated_tipset_epoch metric with the metrics registry must succeed",
        );
    last_validated_tipset_epoch
});
pub static PEER_TIPSET_EPOCH: Lazy<Box<GenericGaugeVec<AtomicI64>>> = Lazy::new(|| {
    let peer_tipset_epoch = Box::new(
        GenericGaugeVec::new(
                Opts::new("peer_tipset_epoch", "peer tipset epoch"),
                &["PEER"],
            )
            .expect("Defining the peer_tipset_epoch metric must succeed"),
    );
    prometheus::default_registry()
        .register(peer_tipset_epoch.clone())
        .expect(
            "Registering the last_validated_tipset_epoch metric with the metrics registry must succeed",
        );
    peer_tipset_epoch
});
pub static NETWORK_HEAD_EVALUATION_ERRORS: Lazy<Box<GenericCounter<AtomicU64>>> = Lazy::new(||
{
    let network_head_evaluation_errors = Box::new(
        GenericCounter::<
            AtomicU64,
        >::new(
                "network_head_evaluation_errors",
                "Total number of network head evaluation errors",
            )
            .expect("Defining the network_head_evaluation_errors metric must succeed"),
    );
    prometheus::default_registry()
        .register(network_head_evaluation_errors.clone())
        .expect(
            "Registering the network_head_evaluation_errors metric with the metrics registry must succeed",
        );
    network_head_evaluation_errors
});
pub static BOOTSTRAP_ERRORS: Lazy<Box<GenericCounter<AtomicU64>>> = Lazy::new(|| {
    let boostrap_errors = Box::new(
        GenericCounter::<
            AtomicU64,
        >::new("bootstrap_errors", "Total number of bootstrap attempts failures")
            .expect("Defining the bootstrap_errors metric must succeed"),
    );
    prometheus::default_registry()
        .register(boostrap_errors.clone())
        .expect(
            "Registering the bootstrap_errors metric with the metrics registry must succeed",
        );
    boostrap_errors
});
pub static FOLLOW_NETWORK_INTERRUPTIONS: Lazy<Box<GenericCounter<AtomicU64>>> = Lazy::new(||
{
    let follow_network_restarts = Box::new(
        GenericCounter::<
            AtomicU64,
        >::new(
                "follow_network_interruptions",
                "Total number of follow network interruptions, where it unexpectedly ended",
            )
            .expect("Defining the follow_network_interruptions metric must succeed"),
    );
    prometheus::default_registry()
        .register(follow_network_restarts.clone())
        .expect(
            "Registering the follow_network_interruptions metric with the metrics registry must succeed",
        );
    follow_network_restarts
});
pub static FOLLOW_NETWORK_ERRORS: Lazy<Box<GenericCounter<AtomicU64>>> = Lazy::new(|| {
    let follow_network_errors = Box::new(
        GenericCounter::<
            AtomicU64,
        >::new("follow_network_errors", "Total number of follow network errors")
            .expect("Defining the follow_network_errors metric must succeed"),
    );
    prometheus::default_registry()
        .register(follow_network_errors.clone())
        .expect(
            "Registering the follow_network_errors metric with the metrics registry must succeed",
        );
    follow_network_errors
});
